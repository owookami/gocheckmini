# 개요
건축인허가 주차장 조회 앱(ParkingFinder)은 공공데이터 포털의 건축HUB API를 활용하여 사용자가 지역별 주차장 정보를 손쉽게 조회할 수 있는 Flutter 모바일 앱입니다. 

이 앱은 복잡한 공공데이터를 직관적인 카드 UI로 제공하여, 건축업무 종사자 및 일반 사용자가 쉽게 주차장 정보에 접근할 수 있도록 합니다. 오프라인에서도 지역 선택이 가능하며, 정확하고 최신의 주차장 데이터를 제공하여 업무 효율성을 극대화합니다.

주요 타겟 사용자는 건축인허가 업무 담당자, 부동산/건설업 종사자, 그리고 일반 시민입니다.

# 핵심 기능
## 1. 메인 화면 및 메뉴 선택
- **주차장 조회**: 일반 주차장 정보를 검색하는 메인 기능
- **부설주차장 조회**: 건물에 부설된 주차장 정보를 별도로 검색
- **직관적인 UI**: 2개의 가로 버튼으로 명확한 기능 구분
- **중요한 이유**: 사용자가 원하는 주차장 유형을 명확히 선택할 수 있어 검색 효율성 증대

## 2. 계층적 지역 선택 시스템
- **3단계 선택**: 시도 → 시군구 → 동/읍/면 순서로 단계적 선택
- **동적 업데이트**: 상위 지역 선택 시 하위 지역 목록 자동 갱신
- **오프라인 지원**: SQLite 로컬 데이터베이스 활용으로 인터넷 연결 없이도 지역 선택 가능
- **중요한 이유**: 전국 모든 지역을 체계적으로 검색할 수 있으며, 오프라인에서도 작동

## 3. API 연동 및 데이터 조회
- **getApPklotInfo API**: 일반 주차장 정보 조회
- **getApAtchPklotInfo API**: 부설주차장 정보 조회
- **실시간 데이터**: 공공데이터 포털의 최신 정보 제공
- **에러 처리**: 네트워크 오류, API 오류에 대한 적절한 처리 및 재시도 로직

## 4. 검색 결과 표시
- **카드 UI**: 각 주차장 정보를 개별 카드로 표시
- **주요 정보**: 주차장명, 주소, 허가번호, 등록일, 총주차대수 등
- **페이징**: 대량 데이터 효율적 처리를 위한 무한스크롤 또는 더보기 기능
- **새로고침**: Pull-to-refresh로 최신 데이터 갱신

## 5. 오프라인 지역 데이터 관리
- **로컬 데이터베이스**: 전국 시도/시군구/동 코드 정보 저장
- **초기 데이터 적재**: 앱 첫 실행 시 지역 코드 데이터 자동 설치
- **빠른 응답**: 네트워크 연결 없이도 즉시 지역 선택 가능

# 사용자 경험
## 사용자 페르소나
### 1차 사용자: 건축인허가 업무 담당자
- 연령: 30-50세
- 직업: 공무원, 건축사무소 직원
- 니즈: 허가 관련 주차장 정보 신속 조회, 정확하고 최신 데이터 필요
- 사용 환경: 사무실, 현장 방문 중

### 2차 사용자: 부동산/건설업 종사자  
- 연령: 25-45세
- 직업: 부동산 중개사, 건설회사 직원, 개발업체 직원
- 니즈: 개발 전 주차장 현황 파악, 지역별 주차 인프라 분석
- 사용 환경: 이동 중, 현장, 사무실

### 3차 사용자: 일반 시민
- 연령: 모든 연령대
- 니즈: 거주지 주변 주차장 정보 관심, 간편한 검색 인터페이스 선호
- 사용 환경: 집, 이동 중

## 주요 사용자 플로우
### 기본 검색 플로우
1. 앱 실행 → 메인 화면 진입
2. 검색 유형 선택 (주차장조회/부설주차장조회)
3. 지역 선택 (시도 → 시군구 → 동)
4. 검색 실행 버튼 클릭
5. 로딩 화면 → 결과 화면 표시
6. 카드 리스트에서 원하는 정보 확인

### 에러 처리 플로우
1. 네트워크 오류 → 에러 메시지 표시 → 재시도 옵션 제공
2. API 오류 → 적절한 안내 메시지 → 다른 검색 조건 제안
3. 빈 결과 → "검색 결과가 없습니다" 메시지 → 검색 조건 변경 제안

## UI/UX 고려사항
- **Material Design 3.0**: 최신 디자인 가이드라인 준수
- **접근성**: 고대비 색상, 적절한 텍스트 크기, 스크린 리더 지원
- **반응형**: 다양한 화면 크기에 적응하는 유연한 레이아웃
- **일관성**: 전체 앱에서 통일된 디자인 언어 사용

# 기술 아키텍처
## 시스템 컴포넌트
### 프론트엔드
- **프레임워크**: Flutter 3.16+ (Dart 3.2+)
- **상태관리**: Riverpod 2.4+
- **라우팅**: GoRouter 12.0+
- **HTTP 클라이언트**: dio 5.3+
- **로컬 데이터베이스**: sqflite 2.3+

### 백엔드 API
- **공공데이터 포털**: 건축HUB API 활용
- **주요 엔드포인트**:
  - getApPklotInfo (주차장 조회)
  - getApAtchPklotInfo (부설주차장 조회)

## 데이터 모델
### ParkingLot (주차장 정보)
```dart
class ParkingLot {
  final String pklotNm;        // 주차장명
  final String ldongAdr;       // 주소
  final String hmpgPlc;        // 허가번호
  final String atchPklotGubun; // 부설주차장구분
  final String permitYMD;      // 허가일자
  final String? totalPklot;    // 총주차대수
}
```

### Region (지역 정보)
```dart
class Region {
  final String code;  // 지역코드
  final String name;  // 지역명
}

class Bjdong extends Region {
  final String bun;   // 번
  final String ji;    // 지
}
```

## 아키텍처 패턴
- **Clean Architecture**: 계층 분리를 통한 유지보수성 향상
- **MVVM**: 화면과 비즈니스 로직 분리
- **Repository Pattern**: 데이터 소스 추상화
- **Provider Pattern**: Riverpod을 통한 의존성 주입

## 폴더 구조
```
lib/
├── main.dart                    // 앱 진입점
├── app/                         // 앱 전역 설정
│   ├── router.dart             // 라우팅 설정
│   ├── providers.dart          // 전역 프로바이더
│   └── theme.dart              // 테마 설정
├── features/parking/           // 주차장 기능 모듈
│   ├── data/                   // 데이터 계층
│   │   ├── models/             // 데이터 모델
│   │   ├── repositories/       // 저장소 구현
│   │   └── datasources/        // 데이터 소스
│   ├── domain/                 // 도메인 계층
│   │   ├── entities/           // 엔티티
│   │   ├── repositories/       // 저장소 인터페이스
│   │   └── usecases/           // 비즈니스 로직
│   └── presentation/           // 프레젠테이션 계층
│       ├── screens/            // 화면
│       ├── widgets/            // 위젯
│       └── providers/          // 상태 프로바이더
├── core/                       // 공통 기능
│   ├── constants/              // 상수
│   ├── utils/                  // 유틸리티
│   └── widgets/                // 공통 위젯
└── database/                   // 데이터베이스 관련
    ├── database_helper.dart    // DB 헬퍼
    └── migrations/             // 마이그레이션
```

## API 및 통합
### 건축HUB API 연동
- **Base URL**: https://apis.data.go.kr/1613000/ArchPmsHubService
- **인증**: 공공데이터 포털 발급 API 키 사용
- **응답 형식**: XML (파싱하여 Dart 객체로 변환)
- **에러 처리**: HTTP 상태 코드 및 API 에러 코드 기반 처리

### 로컬 데이터베이스
- **SQLite**: 지역 코드 정보 저장
- **테이블**:
  - provinces (시도)
  - sigungus (시군구)  
  - bjdongs (읍면동)

## 인프라 요구사항
### 개발 환경
- **Flutter SDK**: 3.16 이상
- **Dart SDK**: 3.2 이상
- **Android Studio** 또는 **VS Code**
- **Android SDK**: API 21 이상
- **iOS SDK**: iOS 12 이상

### 배포 환경
- **Android**: Google Play Store
- **iOS**: Apple App Store
- **빌드**: CI/CD 파이프라인 구성 권장

# 개발 로드맵
## MVP 요구사항 (Phase 1-3)
### 핵심 기능만 포함한 최소 실행 가능한 제품
- 기본 프로젝트 설정 및 폴더 구조
- SQLite 로컬 데이터베이스 구현
- 지역 선택 기능 (시도 → 시군구 → 동)
- API 연동 및 기본 검색 기능
- 간단한 결과 표시 화면

## 개선된 사용자 경험 (Phase 4-5)
### 사용자 친화적인 인터페이스 및 기능 강화
- 완성도 높은 UI/UX 구현
- 카드형 결과 표시
- 로딩 및 에러 상태 처리
- Pull-to-refresh 기능
- 페이징 처리

## 향후 개선사항 (Phase 6+)
### 추가 기능 및 최적화
- 즐겨찾기 기능
- 검색 히스토리
- 지도 연동 (Google Maps)
- 오프라인 캐싱 확장
- 성능 최적화

## 단계별 개발 일정
### Phase 1: 프로젝트 기반 구축 (1-2일)
- Flutter 프로젝트 초기화
- 패키지 의존성 설정
- 기본 폴더 구조 생성
- 환경 변수 설정
- 기본 라우팅 구현

### Phase 2: 데이터 계층 구현 (2-3일)
- SQLite 데이터베이스 설계
- 지역 코드 데이터 모델 정의
- API 클라이언트 구현
- Repository 패턴 구현
- 기본 데이터 CRUD 작업

### Phase 3: 비즈니스 로직 구현 (2-3일)
- Riverpod 상태 관리 설정
- UseCase 클래스 구현
- API 호출 로직 구현
- 지역 선택 로직 구현

### Phase 4: 사용자 인터페이스 구현 (3-4일)
- 메인 화면 UI 구현
- 지역 선택 위젯 구현
- 검색 결과 화면 구현
- 주차장 정보 카드 컴포넌트
- 로딩 및 에러 화면

### Phase 5: 통합 및 테스트 (2-3일)
- 전체 플로우 통합
- 단위 테스트 작성
- 위젯 테스트 작성
- 통합 테스트 실행
- 버그 수정 및 최적화

### Phase 6: 배포 준비 (1-2일)
- 앱 아이콘 및 스플래시 스크린
- Android/iOS 빌드 설정
- 릴리즈 빌드 최적화
- 스토어 등록 준비

# 논리적 의존성 체인
## 기반 구축 단계 (가장 먼저 구현해야 할 기능들)
### 1. 프로젝트 설정 및 구조
- **우선순위**: 최고
- **이유**: 모든 개발의 기반이 되는 설정
- **포함 내용**: Flutter 프로젝트 초기화, 폴더 구조, 패키지 의존성

### 2. 데이터 모델 정의
- **의존성**: 프로젝트 설정 완료 후
- **이유**: API 응답과 로컬 데이터 구조의 기준이 됨
- **포함 내용**: ParkingLot, Region, Bjdong 클래스

### 3. 로컬 데이터베이스 구현
- **의존성**: 데이터 모델 완료 후
- **이유**: 오프라인 지역 선택의 핵심 기능
- **포함 내용**: SQLite 설정, 지역 코드 데이터 적재

## 핵심 기능 구현 단계
### 4. API 클라이언트 구현
- **의존성**: 데이터 모델 완료 후
- **이유**: 외부 데이터 소스와의 연결점
- **포함 내용**: HTTP 클라이언트, API 호출 로직, 에러 처리

### 5. Repository 및 상태 관리
- **의존성**: 로컬 DB와 API 클라이언트 완료 후
- **이유**: 데이터 소스를 통합하고 UI에 제공하는 중간 계층
- **포함 내용**: Repository 구현, Riverpod 프로바이더

### 6. 기본 UI 구현
- **의존성**: 상태 관리 완료 후
- **이유**: 사용자가 실제로 상호작용할 수 있는 인터페이스
- **포함 내용**: 메인 화면, 지역 선택 위젯

## 사용자 경험 개선 단계
### 7. 검색 결과 화면
- **의존성**: 기본 UI와 데이터 플로우 완료 후
- **이유**: 앱의 핵심 가치를 제공하는 화면
- **포함 내용**: 결과 리스트, 카드 UI, 페이징

### 8. 에러 처리 및 로딩 상태
- **의존성**: 주요 기능 완료 후
- **이유**: 안정적인 사용자 경험 제공
- **포함 내용**: 로딩 인디케이터, 에러 메시지, 재시도 로직

### 9. 성능 최적화 및 테스트
- **의존성**: 모든 기능 완료 후
- **이유**: 제품 품질 보장
- **포함 내용**: 테스트 코드, 성능 개선, 버그 수정

## 빠른 프로토타입 경로 (MVP)
1. **1일차**: 프로젝트 설정 + 기본 UI 틀
2. **2일차**: 로컬 데이터베이스 + 지역 선택 기능
3. **3일차**: API 연동 + 기본 검색 기능
4. **4일차**: 결과 표시 + 기본 에러 처리
5. **5일차**: 통합 테스트 + 버그 수정

이 순서를 따르면 5일 만에 기본적으로 작동하는 앱을 구현할 수 있으며, 이후 단계적으로 기능을 개선해 나갈 수 있습니다.

# 위험 요소 및 완화방안
## 기술적 도전과제
### API 응답 속도 및 안정성
- **위험**: 공공 API의 느린 응답 속도나 일시적 장애
- **완화방안**: 
  - 적절한 timeout 설정 (5초)
  - 재시도 로직 구현 (최대 3회)
  - 로딩 인디케이터로 사용자 경험 개선
  - 캐싱 메커니즘 도입 고려

### 대용량 데이터 처리
- **위험**: 검색 결과가 많을 경우 앱 성능 저하
- **완화방안**:
  - 페이징 처리 구현 (페이지당 20개 항목)
  - ListView.builder 활용한 효율적 렌더링
  - 가상화 리스트 구현
  - 메모리 사용량 모니터링

### 크로스플랫폼 호환성
- **위험**: Android와 iOS에서 다른 동작 또는 성능
- **완화방안**:
  - Platform-specific 코드 최소화
  - 양쪽 플랫폼에서 철저한 테스트
  - Flutter의 Material Design 컴포넌트 활용
  - 플랫폼별 빌드 설정 최적화

## MVP 구현 전략
### 핵심 기능 우선 구현
- **전략**: 완벽한 기능보다는 작동하는 기본 기능 우선
- **범위**: 
  - 지역 선택 → API 호출 → 결과 표시의 기본 플로우
  - 최소한의 UI/UX (Material Design 기본 컴포넌트 활용)
  - 기본적인 에러 처리만 구현

### 점진적 개선 방식
- **1차**: 기본 기능만 작동하는 버전
- **2차**: UI/UX 개선 및 에러 처리 강화
- **3차**: 성능 최적화 및 고급 기능 추가

### 사용자 피드백 수집
- **방법**: 초기 버전을 소수 사용자에게 배포
- **목적**: 실제 사용 패턴 파악 및 우선순위 조정
- **반영**: 피드백을 바탕으로 개발 방향 수정

## 자원 제약 관리
### 개발 시간 최적화
- **위험**: 예상보다 긴 개발 시간
- **완화방안**:
  - 기능 범위를 명확히 정의하고 준수
  - 재사용 가능한 컴포넌트 우선 개발
  - 외부 패키지 적극 활용
  - 코드 생성 도구 활용 (build_runner)

### API 키 및 quota 관리
- **위험**: API 호출 한도 초과 또는 키 노출
- **완화방안**:
  - 환경 변수를 통한 API 키 관리
  - API 호출 횟수 모니터링
  - 캐싱으로 불필요한 API 호출 방지
  - 에러 시 재시도 로직에 백오프 구현

### 유지보수성 확보
- **위험**: 코드 복잡도 증가로 인한 유지보수 어려움
- **완화방안**:
  - Clean Architecture 패턴 적용
  - 충분한 테스트 코드 작성
  - 코드 리뷰 프로세스 도입
  - 문서화 병행

# 부록
## 공공데이터 API 상세 정보
### getApPklotInfo (주차장 조회)
```
URL: https://apis.data.go.kr/1613000/ArchPmsHubService/getApPklotInfo
Method: GET
Parameters:
  - serviceKey: API 인증키
  - sigunguCd: 시군구코드
  - bjdongCd: 법정동코드
  - bun: 번지
  - ji: 지번
  - numOfRows: 한 페이지 결과 수 (기본값: 10)
  - pageNo: 페이지 번호 (기본값: 1)
```

### getApAtchPklotInfo (부설주차장 조회)
```
URL: https://apis.data.go.kr/1613000/ArchPmsHubService/getApAtchPklotInfo
Method: GET
Parameters:
  - serviceKey: API 인증키
  - sigunguCd: 시군구코드
  - bjdongCd: 법정동코드
  - bun: 번지
  - ji: 지번
  - numOfRows: 한 페이지 결과 수 (기본값: 10)
  - pageNo: 페이지 번호 (기본값: 1)
```

## 지역 코드 데이터 구조
### 시도 코드 (Province)
```
서울특별시: 11
부산광역시: 26
대구광역시: 27
인천광역시: 28
... (전국 17개 시도)
```

### 시군구 코드 (Sigungu)
```
서울특별시 종로구: 11110
서울특별시 중구: 11140
서울특별시 용산구: 11170
... (전국 모든 시군구)
```

### 법정동 코드 (Bjdong)
```
5자리 시군구코드 + 5자리 법정동코드
예: 1111010100 (서울특별시 종로구 청운효자동)
```

## 성능 목표 상세
### 응답 시간 목표
- **앱 초기 로딩**: 3초 이내
- **지역 선택 응답**: 200ms 이내
- **API 응답 대기**: 5초 이내
- **화면 전환**: 500ms 이내
- **검색 결과 렌더링**: 1초 이내

### 메모리 사용량 목표
- **최대 힙 메모리**: 100MB 이하
- **이미지 캐시**: 50MB 이하
- **SQLite DB 크기**: 10MB 이하
- **앱 설치 크기**: 20MB 이하

### 배터리 효율성
- **백그라운드 작업**: 최소화
- **네트워크 호출**: 필요 시에만 실행
- **화면 갱신**: 효율적인 상태 관리로 불필요한 rebuild 방지

## 테스트 전략
### 단위 테스트 (Unit Tests)
- **타겟 커버리지**: 80% 이상
- **주요 테스트 영역**:
  - 데이터 모델 직렬화/역직렬화
  - Repository 로직
  - API 클라이언트 응답 처리
  - 비즈니스 로직 (UseCase)

### 위젯 테스트 (Widget Tests)
- **주요 테스트 영역**:
  - 사용자 인터랙션 (버튼 클릭, 드롭다운 선택)
  - 상태 변화에 따른 UI 업데이트
  - 에러 상황에서의 UI 표시

### 통합 테스트 (Integration Tests)
- **전체 사용자 플로우 테스트**:
  - 지역 선택부터 결과 표시까지 전체 과정
  - 네트워크 연결 없는 상황에서의 동작
  - API 에러 상황에서의 처리

## 배포 및 운영 계획
### 앱 스토어 등록
- **Android**: Google Play Console을 통한 APK/AAB 업로드
- **iOS**: App Store Connect를 통한 IPA 업로드
- **앱 설명**: 한국어 및 영어 버전 준비
- **스크린샷**: 다양한 기기 크기별 스크린샷 준비

### 업데이트 전략
- **정기 업데이트**: 분기별 기능 추가 및 개선
- **긴급 업데이트**: 중요한 버그 수정 시 즉시 배포
- **버전 관리**: Semantic Versioning (X.Y.Z) 방식 적용

### 모니터링 및 분석
- **크래시 리포팅**: Firebase Crashlytics 활용
- **사용자 분석**: Firebase Analytics 또는 Google Analytics
- **성능 모니터링**: 앱 로딩 시간, API 응답 시간 추적 